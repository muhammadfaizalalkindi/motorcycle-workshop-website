"use strict";

/**
 * VanillaTilt - A lightweight vanilla JS tilt library
 */
class VanillaTilt {
  /**
   * @param {HTMLElement} element - The element to apply the tilt effect on.
   * @param {Object} settings - User settings to override default settings.
   */
  constructor(element, settings = {}) {
    // Validate that the element is a DOM Node
    if (!(element instanceof Node)) {
      throw "Can't initialize VanillaTilt because " + element + " is not a Node.";
    }

    // Initialize element dimensions and positions
    this.width = null;
    this.height = null;
    this.clientWidth = null;
    this.clientHeight = null;
    this.left = null;
    this.top = null;

    // Gyroscope-related properties
    this.gammazero = null;
    this.betazero = null;
    this.lastgammazero = null;
    this.lastbetazero = null;
    this.gyroscopeSamples = null;

    // Transition and update properties
    this.transitionTimeout = null;
    this.updateCall = null;
    this.event = null;

    // Bind update and reset methods to the instance
    this.updateBind = this.update.bind(this);
    this.resetBind = this.reset.bind(this);

    // Set the element and extend default settings with user options
    this.element = element;
    this.settings = this.extendSettings(settings);

    // Determine tilt direction
    this.reverse = this.settings.reverse ? -1 : 1;

    // Determine if glare effect is enabled
    this.glare = VanillaTilt.isSettingTrue(this.settings.glare);
    this.glarePrerender = VanillaTilt.isSettingTrue(this.settings["glare-prerender"]);

    // Check for full page listening and gyroscope support
    this.fullPageListening = VanillaTilt.isSettingTrue(this.settings["full-page-listening"]);
    this.gyroscope = VanillaTilt.isSettingTrue(this.settings.gyroscope);

    // Set initial gyroscope samples
    this.gyroscopeSamples = this.settings.gyroscopeSamples;

    // Determine the element that will listen for mouse events
    this.elementListener = this.getElementListener();

    // Setup glare effect if enabled
    if (this.glare) {
      this.prepareGlare();
    }

    // Update viewport size if full page listening is enabled
    if (this.fullPageListening) {
      this.updateClientSize();
    }

    // Add necessary event listeners
    this.addEventListeners();

    // Initialize tilt state
    this.reset();
    this.updateInitialPosition();
  }

  /**
   * Utility method to check if a setting is considered "true"
   * @param {any} setting 
   * @returns {boolean}
   */
  static isSettingTrue(setting) {
    return setting === "" || setting === true || setting === 1;
  }

  /**
   * Determines which element should listen to mouse events.
   * @returns {HTMLElement}
   */
  getElementListener() {
    if (this.fullPageListening) return window.document;

    if (typeof this.settings["mouse-event-element"] === "string") {
      const mouseEventElement = document.querySelector(this.settings["mouse-event-element"]);
      if (mouseEventElement) return mouseEventElement;
    }

    return this.settings["mouse-event-element"] instanceof Node
      ? this.settings["mouse-event-element"]
      : this.element;
  }

  /**
   * Adds mouse and window event listeners.
   */
  addEventListeners() {
    this.onMouseEnterBind = this.onMouseEnter.bind(this);
    this.onMouseMoveBind = this.onMouseMove.bind(this);
    this.onMouseLeaveBind = this.onMouseLeave.bind(this);
    this.onWindowResizeBind = this.onWindowResize.bind(this);
    this.onDeviceOrientationBind = this.onDeviceOrientation.bind(this);

    this.elementListener.addEventListener("mouseenter", this.onMouseEnterBind);
    this.elementListener.addEventListener("mouseleave", this.onMouseLeaveBind);
    this.elementListener.addEventListener("mousemove", this.onMouseMoveBind);

    if (this.glare || this.fullPageListening) {
      window.addEventListener("resize", this.onWindowResizeBind);
    }

    if (this.gyroscope) {
      window.addEventListener("deviceorientation", this.onDeviceOrientationBind);
    }
  }

  /**
   * Removes previously added event listeners.
   */
  removeEventListeners() {
    this.elementListener.removeEventListener("mouseenter", this.onMouseEnterBind);
    this.elementListener.removeEventListener("mouseleave", this.onMouseLeaveBind);
    this.elementListener.removeEventListener("mousemove", this.onMouseMoveBind);

    if (this.gyroscope) {
      window.removeEventListener("deviceorientation", this.onDeviceOrientationBind);
    }

    if (this.glare || this.fullPageListening) {
      window.removeEventListener("resize", this.onWindowResizeBind);
    }
  }

  /**
   * Destroys the instance and cleans up event listeners and timeouts.
   */
  destroy() {
    clearTimeout(this.transitionTimeout);
    if (this.updateCall !== null) {
      cancelAnimationFrame(this.updateCall);
    }
    this.reset();
    this.removeEventListeners();
    this.element.vanillaTilt = null;
    delete this.element.vanillaTilt;
    this.element = null;
  }

  /**
   * Handles device orientation events (gyroscope).
   * @param {DeviceOrientationEvent} event 
   */
  onDeviceOrientation(event) {
    if (event.gamma === null || event.beta === null) return;

    this.updateElementPosition();

    if (this.gyroscopeSamples > 0) {
      this.lastgammazero = this.gammazero;
      this.lastbetazero = this.betazero;

      if (this.gammazero === null) {
        this.gammazero = event.gamma;
        this.betazero = event.beta;
      } else {
        this.gammazero = (event.gamma + this.lastgammazero) / 2;
        this.betazero = (event.beta + this.lastbetazero) / 2;
      }

      this.gyroscopeSamples -= 1;
    }

    const totalAngleX = this.settings.gyroscopeMaxAngleX - this.settings.gyroscopeMinAngleX;
    const totalAngleY = this.settings.gyroscopeMaxAngleY - this.settings.gyroscopeMinAngleY;
    const anglePerPixelX = totalAngleX / this.width;
    const anglePerPixelY = totalAngleY / this.height;

    const posX = (event.gamma - (this.settings.gyroscopeMinAngleX + this.gammazero)) / anglePerPixelX;
    const posY = (event.beta - (this.settings.gyroscopeMinAngleY + this.betazero)) / anglePerPixelY;

    if (this.updateCall !== null) {
      cancelAnimationFrame(this.updateCall);
    }

    this.event = {
      clientX: posX + this.left,
      clientY: posY + this.top
    };

    this.updateCall = requestAnimationFrame(this.updateBind);
  }

  /**
   * Handles mouse enter event.
   */
  onMouseEnter() {
    this.updateElementPosition();
    this.element.style.willChange = "transform";
    this.setTransition();
  }

  /**
   * Handles mouse move event.
   * @param {MouseEvent} event 
   */
  onMouseMove(event) {
    if (this.updateCall !== null) {
      cancelAnimationFrame(this.updateCall);
    }
    this.event = event;
    this.updateCall = requestAnimationFrame(this.updateBind);
  }

  /**
   * Handles mouse leave event.
   */
  onMouseLeave() {
    this.setTransition();
    if (this.settings.reset) {
      requestAnimationFrame(this.resetBind);
    }
  }

  /**
   * Resets the tilt effect.
   */
  reset() {
    this.event = {
      clientX: this.left + this.width / 2,
      clientY: this.top + this.height / 2
    };
    if (this.element && this.element.style) {
      this.element.style.transform = `perspective(${this.settings.perspective}px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`;
    }
    this.resetGlare();
  }

  /**
   * Resets the glare effect.
   */
  resetGlare() {
    if (this.glare) {
      this.glareElement.style.transform = "rotate(180deg) translate(-50%, -50%)";
      this.glareElement.style.opacity = "0";
    }
  }

  /**
   * Sets the initial tilt position based on user settings.
   */
  updateInitialPosition() {
    if (this.settings.startX === 0 && this.settings.startY === 0) return;

    this.onMouseEnter();
    if (this.fullPageListening) {
      this.event = {
        clientX: ((this.settings.startX + this.settings.max) / (2 * this.settings.max)) * this.clientWidth,
        clientY: ((this.settings.startY + this.settings.max) / (2 * this.settings.max)) * this.clientHeight
      };
    } else {
      this.event = {
        clientX: this.left + ((this.settings.startX + this.settings.max) / (2 * this.settings.max)) * this.width,
        clientY: this.top + ((this.settings.startY + this.settings.max) / (2 * this.settings.max)) * this.height
      };
    }

    // Temporarily set scale to 1 for the initial update
    const initialScale = this.settings.scale;
    this.settings.scale = 1;
    this.update();
    this.settings.scale = initialScale;
    this.resetGlare();
  }

  /**
   * Computes the tilt values based on mouse or gyroscope events.
   * @returns {Object} Object containing tilt values and angles.
   */
  getValues() {
    let x, y;
    if (this.fullPageListening) {
      x = this.event.clientX / this.clientWidth;
      y = this.event.clientY / this.clientHeight;
    } else {
      x = (this.event.clientX - this.left) / this.width;
      y = (this.event.clientY - this.top) / this.height;
    }
    // Clamp values between 0 and 1
    x = Math.min(Math.max(x, 0), 1);
    y = Math.min(Math.max(y, 0), 1);

    return {
      tiltX: (this.reverse * (this.settings.max - x * this.settings.max * 2)).toFixed(2),
      tiltY: (this.reverse * (y * this.settings.max * 2 - this.settings.max)).toFixed(2),
      percentageX: 100 * x,
      percentageY: 100 * y,
      angle: Math.atan2(
        this.event.clientX - (this.left + this.width / 2),
        -(this.event.clientY - (this.top + this.height / 2))
      ) * (180 / Math.PI)
    };
  }

  /**
   * Updates the element's position relative to the viewport.
   */
  updateElementPosition() {
    const rect = this.element.getBoundingClientRect();
    this.width = this.element.offsetWidth;
    this.height = this.element.offsetHeight;
    this.left = rect.left;
    this.top = rect.top;
  }

  /**
   * Applies the tilt transformation and glare effect.
   */
  update() {
    const values = this.getValues();
    this.element.style.transform = `perspective(${this.settings.perspective}px) rotateX(${
      this.settings.axis === "x" ? 0 : values.tiltY
    }deg) rotateY(${this.settings.axis === "y" ? 0 : values.tiltX}deg) scale3d(${this.settings.scale}, ${this.settings.scale}, ${this.settings.scale})`;

    if (this.glare) {
      this.glareElement.style.transform = `rotate(${values.angle}deg) translate(-50%, -50%)`;
      this.glareElement.style.opacity = `${(values.percentageY * this.settings["max-glare"]) / 100}`;
    }

    this.element.dispatchEvent(new CustomEvent("tiltChange", { detail: values }));
    this.updateCall = null;
  }

  /**
   * Prepares and inserts the glare elements if glare is enabled.
   */
  prepareGlare() {
    if (!this.glarePrerender) {
      const glareWrapper = document.createElement("div");
      glareWrapper.classList.add("js-tilt-glare");
      const glareInner = document.createElement("div");
      glareInner.classList.add("js-tilt-glare-inner");
      glareWrapper.appendChild(glareInner);
      this.element.appendChild(glareWrapper);
    }
    this.glareElementWrapper = this.element.querySelector(".js-tilt-glare");
    this.glareElement = this.element.querySelector(".js-tilt-glare-inner");

    if (!this.glarePrerender) {
      Object.assign(this.glareElementWrapper.style, {
        position: "absolute",
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        "pointer-events": "none"
      });
      Object.assign(this.glareElement.style, {
        position: "absolute",
        top: "50%",
        left: "50%",
        "pointer-events": "none",
        "background-image":
          "linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%)",
        transform: "rotate(180deg) translate(-50%, -50%)",
        "transform-origin": "0% 0%",
        opacity: "0"
      });
      this.updateGlareSize();
    }
  }

  /**
   * Updates the size of the glare element based on the element's dimensions.
   */
  updateGlareSize() {
    if (this.glare) {
      const glareSize =
        2 *
        (this.element.offsetWidth > this.element.offsetHeight
          ? this.element.offsetWidth
          : this.element.offsetHeight);
      Object.assign(this.glareElement.style, {
        width: `${glareSize}px`,
        height: `${glareSize}px`
      });
    }
  }

  /**
   * Updates the client viewport size.
   */
  updateClientSize() {
    this.clientWidth =
      window.innerWidth ||
      document.documentElement.clientWidth ||
      document.body.clientWidth;
    this.clientHeight =
      window.innerHeight ||
      document.documentElement.clientHeight ||
      document.body.clientHeight;
  }

  /**
   * Handles window resize events.
   */
  onWindowResize() {
    this.updateGlareSize();
    this.updateClientSize();
  }

  /**
   * Sets transition properties on the element and glare.
   */
  setTransition() {
    clearTimeout(this.transitionTimeout);
    this.element.style.transition = `${this.settings.speed}ms ${this.settings.easing}`;
    if (this.glare) {
      this.glareElement.style.transition = `opacity ${this.settings.speed}ms ${this.settings.easing}`;
    }
    this.transitionTimeout = setTimeout(() => {
      this.element.style.transition = "";
      if (this.glare) {
        this.glareElement.style.transition = "";
      }
    }, this.settings.speed);
  }

  /**
   * Merges default settings with user-provided settings and data attributes.
   * @param {Object} settings 
   * @returns {Object} Extended settings
   */
  extendSettings(settings) {
    const defaultSettings = {
      reverse: false,
      max: 15,
      startX: 0,
      startY: 0,
      perspective: 1000,
      easing: "cubic-bezier(.03,.98,.52,.99)",
      scale: 1,
      speed: 300,
      transition: true,
      axis: null,
      glare: false,
      "max-glare": 1,
      "glare-prerender": false,
      "full-page-listening": false,
      "mouse-event-element": null,
      reset: true,
      gyroscope: true,
      gyroscopeMinAngleX: -45,
      gyroscopeMaxAngleX: 45,
      gyroscopeMinAngleY: -45,
      gyroscopeMaxAngleY: 45,
      gyroscopeSamples: 10
    };

    const extendedSettings = {};
    for (let key in defaultSettings) {
      if (key in settings) {
        extendedSettings[key] = settings[key];
      } else if (this.element.hasAttribute(`data-tilt-${key}`)) {
        let attributeValue = this.element.getAttribute(`data-tilt-${key}`);
        try {
          extendedSettings[key] = JSON.parse(attributeValue);
        } catch (e) {
          extendedSettings[key] = attributeValue;
        }
      } else {
        extendedSettings[key] = defaultSettings[key];
      }
    }
    return extendedSettings;
  }

  /**
   * Initializes VanillaTilt on one or more elements.
   * @param {HTMLElement|NodeList|Array} elements 
   * @param {Object} settings 
   */
  static init(elements, settings) {
    if (elements instanceof Node) {
      elements = [elements];
    }
    if (elements instanceof NodeList) {
      elements = [].slice.call(elements);
    }
    if (elements instanceof Array) {
      elements.forEach(element => {
        if (!("vanillaTilt" in element)) {
          element.vanillaTilt = new VanillaTilt(element, settings);
        }
      });
    }
  }
}

// Auto-initialize on elements with [data-tilt] attribute if the document exists
if (typeof document !== "undefined") {
  window.VanillaTilt = VanillaTilt;
  VanillaTilt.init(document.querySelectorAll("[data-tilt]"));
}

// For module systems (optional)
// export default VanillaTilt;
